package com.norsez.dsp.block.sequencer;

import com.norsez.dsp.block.*;
import com.norsez.dsp.synth.Parameter;
import com.norsez.dsp.synth.ParameterDisplay;
import com.norsez.dsp.synth.ParameterManager;

/**
 * <p>Title: ArpSwing </p>
 * <p>Description: Arpeggiator with Swing. Uses SampleClock's sample number output in calculation.</p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: Norsez Orankijanan</p>
 *
 * @author Norsez Orankijanan
 * @version 1.0
 */

public class ArpSwing
        extends DSPBlock implements com.norsez.dsp.block.modulation.ModSource {

    protected double sampleLength, //how many samples till next tick
    nextSampleTick, //the sample number of the next tick
    nextSampleGateOff, // the sample number that we will send gate off message.
    sampleGateLength, // gate length in samples
    bpm, //tempo
    swingedCurrentSample, // delayed Clock sample for swing look up
    _transpose,
    swing; // swing factor

    protected boolean swingTick; //indicates swing tick
    protected double countTillSwingBeat; //delay in samples until the tick of the swing beat.
    protected double gateLength;

    protected Note note; //

    protected final int NUM_MAX_STEPS;
    protected int numActiveSteps;
    protected int[] midiNoteOfStep;
    protected int currentStep;
    protected int transpose;

    protected boolean isActive;

    protected double lastClockSample;


    public ArpSwing(int maxSteps) {
        note = Note.ONE_SIXTEENTH;
        NUM_MAX_STEPS = maxSteps;
        midiNoteOfStep = new int[NUM_MAX_STEPS];
        midiNoteOfStep[0] = 60;
        midiNoteOfStep[1] = 64;
        midiNoteOfStep[2] = 67;
        midiNoteOfStep[3] = 71;
        numActiveSteps = (int) (NUM_MAX_STEPS * 0.5);


        reset();

    }

    /**
     * as a ModSource
     *
     * @return lastValue
     */
    public double getValue() {
        return lastValue;
    }


    public void reset() {
        currentStep = NUM_MAX_STEPS - 1;
        curRange = MAX_RANGE - 1;
    }

    public double getTempo() {
        return Interpolation.mapToRangeLinear(0, DSPSystem.MIN_BPM,
                1, DSPSystem.MAX_BPM, bpm);
    }


    /**
     * @param sampleNumber input from SampleClock.getlastValue()
     * @return the last Gate value generated by this ArpSwing object.
     */
    public double tick(double sampleNumber) {

        if (!isActive()) {
            return 0;
        }

        lastClockSample = sampleNumber;

        if (!swingTick) {

            if (lastClockSample >= this.nextSampleTick) {
                currentStep++;
                if (currentStep >= numActiveSteps) {
                    currentStep = 0;
                    curRange++;
                    if (curRange >= range) {
                        curRange = 0;
                    }
                }

                nextSampleTick += sampleLength;
                nextSampleGateOff = (long) (lastClockSample + this.sampleGateLength);
                lastValue = 1;

            } else if (lastClockSample >= this.nextSampleGateOff && lastValue != 0) {
                lastValue = 0;
                swingTick = !swingTick;
            }
        } else {
            if (lastClockSample >= this.nextSampleTick + this.countTillSwingBeat) {
                currentStep++;
                if (currentStep >= numActiveSteps) {
                    currentStep = 0;
                    curRange++;
                    if (curRange >= range) {
                        curRange = 0;
                    }
                }
                nextSampleTick += sampleLength;
                nextSampleGateOff = (long) (Math.min(lastClockSample +
                        this.sampleGateLength,
                        nextSampleTick - 1));
                lastValue = 1;
            } else if (lastClockSample >= this.nextSampleGateOff && lastValue != 0) {
                lastValue = 0;
                swingTick = !swingTick;
            }
        }

        return lastValue;
    }

    public void setActive(boolean b) {
        isActive = b;
    }

    public void setActive(double i) {
        if (i == 0) {
            isActive = false;
            lastValue = 0;
        } else {
            isActive = true;
        }
    }

    public boolean isActive() {
        return isActive;
    }

    public double getGateValue() {
        return lastValue;
    }

    public double getRawNote() {

        int temp = midiNoteOfStep[currentStep] + transpose + 12 * (curRange);
        if (temp < 0) {
            temp = 0;
        }
        if (temp > 127) {
            temp = 127;
        }
        return temp * DSPSystem.ONE_OVER_127;
    }

    public double getCps() {
        return Interpolation.linear(Table.T_NOTE2CPS, getRawNote());
    }

    public void setSwing(double s) {
        swing = s;

        countTillSwingBeat = (long) (s * sampleLength) - 1;

    }

    /**
     * @param bpm tempo in Beat Per Minute
     */
    public void setTempoByBpm(double bpm) {
        sampleLength = DSPSystem.getSamplingRate() * 4 / (bpm * note.getFactor() / (60.0));
    }

    /**
     * @param t normalized tempo 0..1
     */
    public void setTempo(double t) {
        bpm = t;
        double temp = Interpolation.mapToRangeLinear(0.0, DSPSystem.MIN_BPM,
                1.0, DSPSystem.MAX_BPM, t);

        setTempoByBpm(temp);
    }

    public void setNote(Note note) {
        this.note = note;
        setTempo(bpm);
    }

    public int getTotalSteps() {
        return this.NUM_MAX_STEPS;
    }

    public int getNumActiveSteps() {
        return this.numActiveSteps;
    }

    public void setActiveSteps(double i) {
        numActiveSteps = (int) (i * this.NUM_MAX_STEPS);
    }

    public void setGateLength(double g) {
        gateLength = g;
        sampleGateLength = (long) (gateLength * sampleLength) - 1;

    }

    public void setNumOfActiveSteps(int i) {
        this.numActiveSteps = i;
    }

    public void setTranspose(int i) {
        transpose = i;
    }

    public String toString() {
        java.text.DecimalFormat df = new java.text.DecimalFormat("0000.##");

        if (getLastValue() != 0) {
            return "#" + df.format(lastClockSample)
                    + ":: gate = " + getLastValue()
                    + ", currentStep = " + currentStep
                    + ", nextGateOff = " + this.nextSampleGateOff
                    + ", gateSampleLength = " + this.sampleGateLength
                    + ", gateLength = " + this.sampleLength
                    + "";
        } else {
            return "#" + df.format(lastClockSample) + ":: note off"
                    //    + ", isSwingTick = " + this.swingTick
                    ;
        }
    }

    public double tick() {
        DSPSystem.unsupported("use tick ( double sampleNumber ) instead");
        return 0;
    }

    /**
     * This sets the tempo directly in number of samples. It should be used for debugging purposes only.
     */
    public void setRawSampleLength(long s) {
        this.sampleLength = s;
    }

    public final static int MAX_TRANSPOSE = 24;

    public void setTranspose(double i) {

        transpose = (int) Interpolation.mapToRangeLinear(0, -MAX_TRANSPOSE, 1,
                MAX_TRANSPOSE, i);

        _transpose = i;
    }

    public void setNoteAt(int step, double note) {
        midiNoteOfStep[step] = (int) (note * 127.0);
    }

    private static final int MAX_RANGE = 5;
    private int range, curRange;

    public void setRange(double r) {
        range = (int) (r * (MAX_RANGE)) + 1;
    }

    public final static com.norsez.dsp.synth.ParameterDisplay RANGE = new com.norsez.dsp.synth.
            ParameterDisplay() {
        public String getDisplay(double v) {
            return "" + (int) (v * MAX_RANGE);
        }
    };

    public final static com.norsez.dsp.synth.ParameterDisplay TRANSPOSE = new com.norsez.dsp.synth.
            ParameterDisplay() {
        public String getDisplay(double v) {
            return "" +
                    (int) (Interpolation.mapToRangeLinear(0, -MAX_TRANSPOSE, 1, MAX_TRANSPOSE,
                            v));
        }
    };


    /**
     * This method will automatically add this ArpSwing's parameters
     * to a ParameterMananger.
     *
     * @param pm        a ParameterManager
     * @param groupname editor tab name of these parameters.
     */
    public void addParametersTo(ParameterManager pm, String groupname, String prefix) {

        int ii;
        if (isActive()) ii = 1; else ii = 0;

        pm.addParameter(new Parameter(prefix + "Play", ii,
                groupname, ParameterDisplay.ON_OFF));
        pm.addParameter(new Parameter(prefix + "Tempo", bpm,
                groupname, ParameterDisplay.BPM));
        pm.addParameter(new Parameter(prefix + "Resolution",
                Note.getAllNotes(), groupname));
        pm.setObject(prefix + " Resolution", note);
        pm.addParameter(new Parameter(prefix + "Swing", swing,
                groupname));
        pm.addParameter(new Parameter(prefix + "Gate", gateLength,
                groupname));
        pm.addParameter(new Parameter(prefix + "Range", this.range / (this.MAX_RANGE - 1.0),
                groupname, this.RANGE));
        pm.addParameter(new Parameter(prefix + "Transpose",
                _transpose,
                groupname, this.TRANSPOSE));
        pm.addParameter(new Parameter(prefix + "Active Steps",
                this.getNumActiveSteps() /
                (double) this.getTotalSteps(), groupname));

        for (int i = 0; i < this.getTotalSteps(); i++) {
            pm.addParameter(new Parameter(prefix + "Step " + i,
                    this.midiNoteOfStep[i] *
                    DSPSystem.ONE_OVER_127, groupname,
                    ParameterDisplay.NOTENAME));
        }

    }

    /**
     * This is used to update this object's parameter by the value registered to
     * the ParameterManager. It is typically called at certain intervals to
     * update changes.
     *
     * @param pm        ParameterManager
     * @param groupname Group name of the parameters
     */
    public void updateParameterValue(ParameterManager pm, String prefix) {
        this.setActive(pm.getParameterValue(prefix + "Play"));
        this.setTempo(pm.getParameterValue(prefix + "Tempo"));
        this.setNote((Note) pm.getParameterObject(prefix + "Resolution"));
        this.setSwing(pm.getParameterValue(prefix + "Swing"));
        this.setGateLength(pm.getParameterValue(prefix + "Gate"));
        this.setRange(pm.getParameterValue(prefix + "Range"));
        this.setTranspose(pm.getParameterValue(prefix + "Transpose"));
        this.setActiveSteps(pm.getParameterValue(prefix + "Active Steps"));
        for (int i = 0; i < this.getTotalSteps(); i++) {
            this.setNoteAt(i, pm.getParameterValue(prefix + "Step " + i));
        }
    }

    public static void main(String[] args) {
        /*
        SampleClock clock = new SampleClock();
        ArpSwing arp = new ArpSwing(8);
        arp.setTempo(.9);
        arp.setNote(Note.ONE_SIXTEENTH);
        DSPSystem.DEBUG_OUT.println(arp.getTempo());

             arp.sampleLength = 12;
             arp.setGateLength(.7);
             arp.setSwing(.25);
             arp.setActive(1);
             arp.setNumOfActiveSteps(4);
             arp.setTranspose(0.5);
             arp.setRange(1.0);
             arp.setNoteAt(0,60/127.0);
             arp.setNoteAt(1,64/127.0);
             arp.setNoteAt(2,67/127.0);
             arp.setNoteAt(3,72/127.0);
             DSPSystem.DEBUG_OUT.println("SampleLength " + arp.sampleLength);
             for (int i=0; i < 250; i++){
          if (i%arp.sampleLength ==0)
            DSPSystem.DEBUG_OUT.println("*******Tick");
          clock.tick();
          arp.tick(clock.getLastValue());
          DSPSystem.DEBUG_OUT.println(arp);
             }
         */
        //DSPSystem.DEBUG_OUT.close();
    }

}